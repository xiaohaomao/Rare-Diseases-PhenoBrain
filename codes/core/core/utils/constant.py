import os
import numpy as np
import scipy
import random

PROJECT_PATH = os.path.dirname(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))
SRC_PATH = os.path.join(PROJECT_PATH, 'core')
DATA_PATH = os.path.join(PROJECT_PATH, 'data')
RESULT_PATH = os.path.join(PROJECT_PATH, 'result')
RESULT_FIG_PATH = os.path.join(RESULT_PATH, 'fig')
MODEL_PATH = os.path.join(PROJECT_PATH, 'model')
EMBEDDING_PATH = os.path.join(PROJECT_PATH, 'embedding')
LOG_PATH = os.path.join(PROJECT_PATH, 'log')
TEMP_PATH = os.path.join(PROJECT_PATH, 'temp')

SEED = 2211

GENDER_MALE = 'MALE'
GENDER_FEMALE = 'FEMALE'
GENDER_NONE = 'GENDER_NONE'

TRAIN_MODE = 0
EVAL_MODE = 1
PREDICT_MODE = 2

DIST_SHORTEST = 'DIST_SHORTEST' #
DIST_MEAN_TURN = 'DIST_MEAN_TURN'   #

GRAPH_ADJLIST = 'ADJLIST'
GRAPH_EDGELIST = 'EDGELIST'

VEC_TYPE_0_1 = 'VEC_TYPE_0_1'
VEC_TYPE_TF = 'VEC_TYPE_TF'
VEC_TYPE_TF_IDF = 'VEC_TYPE_TF_IDF'
VEC_TYPE_IDF = 'VEC_TYPE_IDF'
VEC_TYPE_EMBEDDING = 'VEC_TYPE_EMBEDDING'
VEC_TYPE_0_1_DIM_REDUCT = 'VEC_TYPE_0_1_DIM_REDUCT'
VEC_TYPE_PROB = 'VEC_TYPE_PROB'
VEC_TYPE_LOG_PROB = 'VEC_TYPE_LOG_PROB'

DISEASE_NUM = 10298
# HPO_CODE_NUMBER = 13032
ROOT_HPO_CODE = 'HP:0000001'

PHE_SIM_MICA = 'PHE_SIM_MICA'
PHE_SIM_MINIC = 'PHE_SIM_MINIC'

SET_SIM_ASYMMAX_QD = 'SET_SIM_ASYMMAX_QD'
SET_SIM_ASYMMAX_DQ = 'SET_SIM_ASYMMAX_DQ'
SET_SIM_SYMMAX = 'SET_SIM_SYMMAX'
SET_SIM_EMD = 'SET_SIM_EMD'

PHELIST_ANCESTOR = 'PHELIST_ANCESTOR'
PHELIST_DESCENDENT = 'PHELIST_DESCENDENT'
PHELIST_REDUCE = 'PHELIST_REDUCE'
PHELIST_ORIGIN = 'PHELIST_ORIGIN'
PHELIST_ANCESTOR_DUP = 'PHELIST_ANCESTOR_DUP'

ADJ_MAT_BROTHER = 'ADJ_MAT_BROTHER'
ADJ_MAT_AROUND = 'ADJ_MAT_AROUND'

JSON_FILE_FORMAT = 'JSON'
PKL_FILE_FORMAT = 'PKL'
NPY_FILE_FORMAT = 'NPY'
NPZ_FILE_FORMAT = 'NPZ'
SPARSE_NPZ_FILE_FORMAT = 'SPARSE_NPZ'
JOBLIB_FILE_FORMAT = 'JOBLIB'

GENE_ANNOTATION = 'GENE_ANNOTATION'
DISEASE_ANNOTATION = 'DISEASE_ANNOTATION'

RELU = 'RELU'; TANH = 'TANH'; SIGMOID = 'SIGMOID'

VEC_COMBINE_MEAN = 'VEC_COMBINE_MEAN'
VEC_COMBINE_SUM = 'VEC_COMBINE_SUM'
VEC_COMBINE_MAX = 'VEC_COMBINE_MAX'

VEC_DIST_EUCLID = 'VEC_DIST_EUCLID'
VEC_DIST_COSINE = 'VEC_DIST_COSINE'

OPTIMIZER_SGD = 'OPTIMIZER_SGD'
OPTIMIZER_ADAM = 'OPTIMIZER_ADAM'
OPTIMIZER_RMS = 'OPTIMIZER_RMS'

TRAIN_DATA = 'train'
TEST_DATA = 'test'
VALIDATION_DATA = 'validation'
VALIDATION_TEST_DATA = 'validation_test'
UNLABELED_DATA = 'unlabeled'
CUSTOM_DATA = 'custom'

DATASET_TYPE_M = 'DATASET_TYPE_MATCH'
DATASET_TYPE_I = 'DATASET_TYPE_IMPRECISION'
DATASET_TYPE_S = 'DATASET_TYPE_NOISE_SPECIFIED'
DATASET_TYPE_O = 'DATASET_TYPE_NOISE_OTHERS'

MT_HPO_SOURCE = 'HPO'
MT_ICD10_SOURCE = 'ICD10'
MT_MESH_SOURCE = 'MeSH'
MT_SNOMED_SNMI_SOURCE = 'SNMI'
MT_SNOMED_BDWK_SOURCE = 'SNOMED_BDWK'
MT_UMLS_CHI_SOURCE = 'UMLS_CHI'
MT_ICIBA_SOURCE = 'ICIBA'
MT_BAIDU_SOURCE = 'Baidu'
MT_GOOGLE_SOURCE = 'Google'

ORPHA_MANUAL_ASSERT = 'manual_assertion'
ORPHA_CURINF_ASSERT = 'curator_inference'

DIS_SIM_EUCLIDEAN = 'DIS_SIM_EUCLIDEAN'
DIS_SIM_COSINE = 'DIS_SIM_COSINE'
DIS_SIM_JACCARD = 'DIS_SIM_JACCARD'
DIS_SIM_MICA = 'DIS_SIM_MICA'
DIS_SIM_MICA_LIN = 'DIS_SIM_MICA_LIN'
DIS_SIM_MIN_IC = 'DIS_SIM_MIN_IC'
DIS_SIM_GDDP = 'DIS_SIM_GDDP'
DIS_SIM_ICTODQ_ACROSS = 'DIS_SIM_ICTODQ_ACROSS'
DIS_SIM_SIMTODQ_ACROSS = 'DIS_SIM_SIMTODQ_ACROSS'
DIS_SIM_TREE_DISTANCE = 'DIS_SIM_TREE_DISTANCE'

CLUSTER_PREDICT_MEAN_MAX_TOPK = 'CLUSTER_PREDICT_MEAN_MAX_TOPK'
CLUSTER_PREDICT_MEAN = 'CLUSTER_PREDICT_MEAN'
CLUSTER_PREDICT_CENTER = 'CLUSTER_PREDICT_CENTER'

SORT_P = 'SORT_P'
SORT_P_S = 'SORT_P_S'
SORT_S_P = 'SORT_S_P'

PVALUE_RAW_SCORE_MODEL = 'RAW'
PVALUE_HIST_SCORE_MODEL = 'HIST'

CHOOSE_DIS_GEQ_HPO = 'CHOOSE_DIS_GEQ_HPO'
CHOOSE_DIS_GEQ_IC = 'CHOOSE_DIS_GEQ_IC'

HYPER_TUNE_USER_SCORE = 'HYPER_TUNE_SCORE'
HYPER_TUNE_RANK_SCORE = 'HYPER_TUNE_RANK_SCORE'
HYPER_TUNE_Z_SCORE = 'HYPER_TUNE_Z_SCORE'
HYPER_TUNE_SUCC_Z_SCORE = 'HYPER_TUNE_SUCC_Z_SCORE'
HYPER_TUNE_AVE_SCORE = 'HYPER_TUNE_AVE_SCORE'

SIM_TO_DIST_MAX = 'SIM_TO_DIST_MAX'
SIM_TO_DIST_MIN_MAX_NORM = 'SIM_TO_DIST_MIN_MAX_NORM'
SIM_TO_DIST_E = 'SIM_TO_DIST_E'
SIM_TO_DIST_SIGMOID = 'SIM_TO_DIST_SIGMOID'
SIM_TO_DIST_MIN_MAX_SIGMOID = 'SIM_TO_DIST_MIN_MAX_SIGMOID'
SIM_TO_DIST_DIVIDE_PLUS_1 = 'SIM_TO_DIST_DIVIDE_PLUS_1'

ATT_DOT = 'ATT_DOT'
ATT_MULTIPLY = 'ATT_MULTIPLY'
ATT_ADD = 'ATT_ADD'

DISORDER_GROUP_LEVEL = 'DISORDER_GROUP'
DISORDER_GROUP_LEAF_LEVEL = 'DISORDER_GROUP_LEAF'
DISORDER_LEVEL = 'DISORDER'
DISORDER_SUBTYPE_LEVEL = 'DISORDER_SUBTYPE'

def get_tune_data_names(eval_data):
	if eval_data == VALIDATION_DATA:
		return ['RAMEDIS', 'HMS', 'PUMC']
	elif eval_data == TEST_DATA or eval_data == VALIDATION_TEST_DATA:
		return ['RAMEDIS', 'HMS', 'MME', 'PUMC']
	else:
		raise RuntimeError('Unknown eval data: {}'.format(eval_data))


def get_tune_data_weights(eval_data):
	if eval_data == VALIDATION_DATA:
		return {'RAMEDIS': 1/3, 'HMS': 1/3, 'PUMC': 1/3}
	elif eval_data == TEST_DATA or eval_data == VALIDATION_TEST_DATA:
		return {'RAMEDIS': 1/4, 'HMS':1/4, 'MME': 1/4, 'PUMC': 1/4}
	assert False


def get_tune_metric_names():
	"""Note: The order of list below will be used to calculate average score ()
	"""
	return [
		'Mic.RankMedian',
		'Mic.Recall.10', 'Mac.Recall.10', 'Mic.Recall.3', 'Mac.Recall.3',
		'Mic.Recall.200', 'Mac.Recall.200', 'Mic.Recall.100', 'Mac.Recall.100',
		'Mic.Recall.50', 'Mac.Recall.50', 'Mic.Recall.40', 'Mac.Recall.40',
		'Mic.Recall.30', 'Mac.Recall.30', 'Mic.Recall.20', 'Mac.Recall.20',
		'Mic.Recall.1', 'Mac.Recall.1'
	]

def get_tune_metric_weights():
	return {
		'Mic.Recall.200': 0.0, 'Mac.Recall.200': 0.0, 'Mic.Recall.100': 0.0, 'Mac.Recall.100': 0.0,
		'Mic.Recall.50':0.0, 'Mac.Recall.50':0.0, 'Mic.Recall.40':0.0, 'Mac.Recall.40':0.0,
		'Mic.Recall.30':0.0, 'Mac.Recall.30':0.0, 'Mic.Recall.20':0.0, 'Mac.Recall.20':0.0,
		'Mic.Recall.10':0.5/4, 'Mac.Recall.10':0.5/4, 'Mic.Recall.3':0.5/4, 'Mac.Recall.3':0.5/4,
		'Mic.Recall.1':0.0, 'Mac.Recall.1':0.0, 'Mic.RankMedian':0.5,
	}




if __name__ == '__main__':
	pass

